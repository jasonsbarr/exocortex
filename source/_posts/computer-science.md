---
title: What is Computer Science? The beginning of an introduction
tags:
  - computer science
  - feynman technique
categories:
  - computer science
  - programming
    - python
date: 2020-03-03 10:57:03
---

# What computer science and programming are about

{% blockquote Sequoia https://sequoia-tree.github.io/welcome-to-computer-science.html Welcome to Computer Science %}
[H]ow to think analytically about different kinds of problems, and solve them. That's what computer science is about.
{% endblockquote %}

<!-- more -->

<hr>

{% blockquote Loksa, Ko, et al. https://docs.google.com/presentation/d/17etd_yHLNeUOewTTSSi8MOIKrP0cgL9O_1FYmqQSRME/edit#slide=id.g2359396b65_0_0 Programming, Problem Solving, & Self-Awareness %}
[P]rogramming is fundamentally about the iterative process of refining mental representations of computational problems and solutions and _expressing_ those representations as code.
{% endblockquote %}

## The computer scientist as detective

When I think of a computer scientist the image that comes to mind is a version of Sherlock Holmes. Not the sanitized Holmes of 20th century TV and cinema, but a vulgar, pipe-smoking man wearing a cap that's just past its prime sitting in a leather chair in his study puffing away while his brain turns over the case he's working on.

For those not familiar with Sir Arthur Conan Doyle's actual writings, Holmes was more than a little uncouth. He was a drug addict. He was also a peerless analytical thinker and a master of multiple disciplines in the sciences and humanities.

I see Holmes sitting, eyes closed, a thick, grey haze surrounding him as he blows the smoke from his mouth. He looks idle, but in reality he's doing incredibly hard work inside his head. He runs over the available data, mentally applying multiple concrete scenarios to it, and eventually he will find the one that discards all impossibilities and lets the cold, hard truth emerge.

# Problem solving and iterative refinement

The number one skill a computer scientist and programmer must have is the ability to engineer computational solutions to the problems they encounter on a daily basis.

They do this not just by composing individual programs, but by constructing models that enable them to understand patterns in the data and common threads that let them build algorithms.

## Tactics before tools

When I say "tools" I mean the things most people are likely to commonly associate with computer scientists: the ability to use programming languages, recognition of algorithms, and other such skills that are the direct means by which they solve their problems.

Tools are vital, but they pale in comparison to the tactics that empower constructive use of those very tools in the first place.

Tactics include problem solving strategies and methods to break down larger problems into smaller, more-easily solved ones. It's the ability to build a conceptual model that connects the current problem to ones the scientist has encountered before, so they can use that experience as a jumping-off point for what they're working on now. It's the ability to find defects in one's process for finding solutions so they can improve their ability to create the things they need to engineer at least a provisional solution to the current problem so they can continue iterating on their solution until they've arrived at a comprehensive result.

# Programs and programming

Programming is one of the chief means by which computer scientists solve their problems.

A program is simply a sequence of instructions that tells a computer how to compute a solution.

Programs are deceptively simple: there are only five basic features of programming. If you can use them all, you can literally write any program that is possible.

1. Input, or some kind of data that goes into the program
2. A series of instructions
3. The ability to decide whether to execute one series of instructions or another
4. The ability to repeat a set of instructions as needed
5. Output, or the data that comes out of the program as the result of its computation

These five things are all it takes to be able to create every solution to every computational problem that exists. You just have to arrange them properly!
